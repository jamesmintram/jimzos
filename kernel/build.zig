const builtin = @import("builtin");
const std = @import("std");

const io = std.io;
const os = std.os;
const fs = std.fs;

const Builder = std.build.Builder;

const thread = @import("src/thread.zig");

pub fn write_struct_def(comptime T : type) void {
    
    const file = fs.cwd().createFile("src/arch/aarch64/struct_defs_" ++ @typeName(T) ++ ".h", .{}) catch unreachable;
    defer file.close();

    var writer = fs.File.writer(file);

    var _e = writer.print("// NOTE THIS FILE IS AUTO GENERATED BY BUILD.ZIG\n", .{});

    switch (@typeInfo(T)) {
        .Struct => |StructT| {
            inline for (StructT.fields) |f, i| 
            {
                const stdout = std.io.getStdOut().writer();
                var _err = writer.print("#define {}_{} {}\n", .{@typeName(T), f.name, @byteOffsetOf(T, f.name)});
            }

            var _err = writer.print("#define {}__size {}\n", .{@typeName(T), @sizeOf(T)});
        },
        else => @compileError("Thread type not a struct"),
    }
}

pub fn build(b: *Builder) void {

    write_struct_def(thread.Thread);
    write_struct_def(thread.CPUFrame);

    const want_gdb = b.option(bool, "gdb", "Build for QEMU gdb server") orelse false;
    const want_pty = b.option(bool, "pty", "Create a separate serial port path") orelse false;

    const mode = b.standardReleaseOptions();
    
    const exe = b.addExecutable("kernel8.elf", "src/kernel.zig");
    exe.addAssemblyFile("src/arch/aarch64/head.S");
    exe.addAssemblyFile("src/arch/aarch64/crt0.S");
    exe.addAssemblyFile("src/arch/aarch64/exception.S");
    exe.addAssemblyFile("src/arch/aarch64/context.S");
    exe.setBuildMode(mode);

    exe.setLinkerScriptPath("src/arch/aarch64/linker.ld");
    // Use eabihf for freestanding arm code with hardware float support

    var features_sub = std.Target.Cpu.Feature.Set.empty;
    features_sub.addFeature(@enumToInt(std.Target.aarch64.Feature.neon));
    features_sub.addFeature(@enumToInt(std.Target.aarch64.Feature.fp_armv8));

    const target = std.zig.CrossTarget{
        .cpu_arch = .aarch64,
        .os_tag = .freestanding,
        .cpu_features_sub = features_sub,
        .cpu_model = .{ .explicit = &std.Target.aarch64.cpu.generic },
    };

    exe.setTarget(target);

    const dump_step = b.step("dump", "Dump symbols");
    dump_step.dependOn(&exe.step);

    // const qemu = b.step("qemu", "run kernel in qemu");

    // const qemu_path = if (builtin.os == builtin.Os.windows) "C:/Program Files/qemu/qemu-system-aarch64.exe" else "qemu-system-aarch64";
    // const run_qemu = b.addSystemCommand([][]const u8 { qemu_path });
    // run_qemu.addArg("-kernel");
    // run_qemu.addArtifactArg(exe);
    // run_qemu.addArgs([][]const u8{
    //     "-m",
    //     "256",
    //     "-M",
    //     "raspi3",
    //     "-serial",
    //     if (want_pty) "pty" else "stdio",
    // });
    // if (want_gdb) {
    //     run_qemu.addArgs([][]const u8{
    //         "-S",
    //         "-s",
    //     });
    // }
    // qemu.dependOn(&run_qemu.step);

    b.default_step.dependOn(&exe.step);
    b.installArtifact(exe);
}
